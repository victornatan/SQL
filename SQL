
OBSERVAÇOES IMPORTANTES:

- AINDA não coloquei index para a melhoria da performance.



USE FABRICAR;

CREATE TABLE CLIENTE(
IDCLIENTE INT PRIMARY KEY IDENTITY,
DATA DATE,
NOME VARCHAR(60),
DATA_DE_NASCIMENTO DATE,
CPF VARCHAR(20) UNIQUE,
CNPJ VARCHAR (25) UNIQUE,
EMAIL VARCHAR(70),
RUA VARCHAR(50),
NUMERO INT,
BAIRRO VARCHAR(30),
CIDADE VARCHAR(30),
ESTADO CHAR(2),
DDD CHAR(2),
TELEFONE VARCHAR(15)
)


CREATE TABLE CARGO(
IDCARGO INT PRIMARY KEY IDENTITY,
NOME VARCHAR(60) NOT NULL,
)


CREATE TABLE FUNCIONARIO (
IDFUNCIONARIO INT PRIMARY KEY IDENTITY,
DATA_DE_ADMISSAO DATE,
NOME VARCHAR(50),
CPF VARCHAR(20) NOT NULL,
PIS VARCHAR(20) NOT NULL,
RUA VARCHAR(30),
NUMERO INT,
BAIRRO VARCHAR(30),
CIDADE VARCHAR(30),
ESTADO CHAR(2),
DDD CHAR(2),
TELEFONE VARCHAR(15),
SEXO CHAR(2),
ID_CARGO INT,
STATUS VARCHAR(30) CHECK(STATUS IN (  'ATIVO','DESLIGADO')),
SALARIO_BRUTO MONEY,
SALARIO_BRUTO_COM_COMISSAO MONEY
)

ALTER TABLE FUNCIONARIO ADD CONSTRAINT FK_FUNCIONARIO_CARGO FOREIGN KEY (ID_CARGO) REFERENCES CARGO (IDCARGO);


CREATE TABLE ESTADO(
IDESTADO INT PRIMARY KEY IDENTITY,
UF CHAR(2)
)

CREATE TABLE AREA_DE_ATUAÇAO_VENDEDOR(
IDVENDEDOR INT PRIMARY KEY IDENTITY,
ID_FUNCIONARIO INT,
ID_ESTADO INT
)

ALTER TABLE AREA_DE_ATUAÇAO_VENDEDOR ADD CONSTRAINT FK_ATUAÇAO_FUNCIONARIO FOREIGN KEY (ID_FUNCIONARIO) REFERENCES FUNCIONARIO (IDFUNCIONARIO);
ALTER TABLE AREA_DE_ATUAÇAO_VENDEDOR ADD CONSTRAINT FK_ATUAÇAO_ESTADO FOREIGN KEY (ID_ESTADO) REFERENCES ESTADO (IDESTADO);

CREATE TABLE FORNECEDOR (
IDFORNECEDOR INT PRIMARY KEY IDENTITY,
DATA_DE_ENTRADA DATE,
NOME VARCHAR(100),
TIPO_DE_MATERIAL VARCHAR(100),
CNPJ VARCHAR(20),
DDD CHAR(2),
TELEFONE VARCHAR(15),
EMAIL VARCHAR(70),
NUMERO INT,
RUA VARCHAR(40),
BAIRRO VARCHAR(30),
CIDADE VARCHAR(30),
ESTADO CHAR(2),
SITUAÇAO VARCHAR(30) CHECK (SITUAÇAO IN ('COMPLETA', 'BLOQUEADO', 'PENDENTE'))

)

CREATE TABLE PRODUTO (
IDPRODUTO INT PRIMARY KEY IDENTITY,
NOME VARCHAR(50),
TIPO VARCHAR(100),
COR VARCHAR(15),
TURBO CHAR(3) CHECK  (TURBO IN ('SIM', 'NAO')),
PORTAS INT,
PREÇO MONEY
)

CREATE TABLE ESTOQUE_DE_MATERIAL (
IDESTOQUE INT PRIMARY KEY IDENTITY,
DATA_DE_ENTRADA DATE,
ID_FORNECEDOR INT,
LOTE VARCHAR(15) UNIQUE,
NOME VARCHAR(60),
TIPO VARCHAR(30),
COR VARCHAR(20),
TAMANHO VARCHAR(30),
QUANTIDADE INT,
DATA_DE_VALIDADE DATE
)

ALTER TABLE ESTOQUE_DE_MATERIAL ADD CONSTRAINT FK_ESTOQUE_FORNECEDOR FOREIGN KEY (ID_FORNECEDOR) REFERENCES FORNECEDOR (IDFORNECEDOR);


CREATE TABLE PEDIDO(
IDPEDIDO INT PRIMARY KEY IDENTITY,
DATA_DE_EMISSAO DATETIME,
ID_CLIENTE INT,
ID_PRODUTO INT,
ID_VENDEDOR INT,
QUANTIDADE INT,
DATA_DE_ENTREGA DATE,
MODO_DE_PAGAMENTO VARCHAR(20) CHECK(MODO_DE_PAGAMENTO IN  ('DINHEIRO', 'PIX', 'CARTAO DE CREDITO','CARTAO DE DEBITO', 'CHEQUE','BOLETO')),
PARCELAS INT DEFAULT '0',
PREÇO_TOTAL DECIMAL(10,2) 
)


ALTER TABLE PEDIDO ADD CONSTRAINT FK_PEDIDO_CLIENTE FOREIGN KEY (ID_CLIENTE) REFERENCES CLIENTE (IDCLIENTE);
ALTER TABLE PEDIDO ADD CONSTRAINT FK_PEDIDO_PRODUTO FOREIGN KEY (ID_PRODUTO) REFERENCES PRODUTO (IDPRODUTO);
ALTER TABLE PEDIDO ADD CONSTRAINT FK_PEDIDO_VENDEDOR FOREIGN KEY (ID_VENDEDOR) REFERENCES AREA_DE_ATUAÇAO_VENDEDOR (IDVENDEDOR);



CREATE TABLE META_VENDEDOR (
IDMETA INT PRIMARY KEY IDENTITY,
ID_VENDEDOR INT,
VALOR_META MONEY,
ANDAMENTO DECIMAL (10,2)

)

ALTER TABLE META_VENDEDOR ADD CONSTRAINT FK_META_VENDEDOR_AREA_DE_ATUAÇAO_VENDEDOR FOREIGN KEY (ID_VENDEDOR) REFERENCES AREA_DE_ATUAÇAO_VENDEDOR (IDVENDEDOR);


CREATE TABLE MATERIAL_PRA_CONSUMO (
IDMATERIAL INT PRIMARY KEY IDENTITY,
DATA_DE_SAIDA DATE,
ID_PEDIDO INT,
ID_ESTOQUE INT,
QUANTIDADE INT
)


ALTER TABLE MATERIAL_PRA_CONSUMO ADD CONSTRAINT FK_MATERIAL_ESTOQUE FOREIGN KEY (ID_ESTOQUE) REFERENCES ESTOQUE_DE_MATERIAL (IDESTOQUE);
ALTER TABLE MATERIAL_PRA_CONSUMO ADD CONSTRAINT FK_METERIAL_PEDIDO FOREIGN KEY (ID_PEDIDO) REFERENCES PEDIDO (IDPEDIDO);



CREATE TABLE PRODUTO_EM_FABRICAÇAO (
IDFABRICAÇAO INT PRIMARY KEY IDENTITY,
DATA DATE,
NOME VARCHAR(60), 
CPF VARCHAR(20),   
CNPJ VARCHAR (25) ,
ID_PEDIDO INT,     
ID_VENDEDOR INT, 
QUANTIDADE INT,   
DATA_DE_ENTREGA DATE,
NOMEP VARCHAR(50),     
TIPO VARCHAR(200),      
COR VARCHAR(15),        
TURBO CHAR(3) CHECK  (TURBO IN ('SIM', 'NAO')), 
PORTAS INT,                                  
STATUS VARCHAR(50) DEFAULT 'ABERTO'  
)


CREATE TABLE NF_CLIENTE (
IDNF INT PRIMARY KEY IDENTITY,
DATA_DE_EMISSAO DATE, 
NOME VARCHAR(60),  
CPF VARCHAR(20), 
QUANTIDADE INT,   
CNPJ_FABRICANTE VARCHAR(30),  
CNPJ VARCHAR (25),  
PREÇO_TOTAL MONEY,  
PROTOCOLO_DE_AUTENTICAÇAO VARCHAR(100) UNIQUE , 
ID_FABRICAÇAO INT,
ID_PEDIDO INT,
NOMEP VARCHAR(50),
TIPO VARCHAR(200),
COR VARCHAR(15),
TURBO CHAR(3),
PORTAS INT
)


CREATE TABLE HISTORICO_META(
IDHISTORICO INT PRIMARY KEY IDENTITY,
ID_VENDEDOR INT,
VALOR_META MONEY,
ANDAMENTO MONEY,
DATA_FINAL_META DATE
)


CREATE TABLE FOLHA_DE_PAGAMENTO(
IDFOLHA INT PRIMARY KEY IDENTITY,
DATA_DO_PAGAMENTO DATE,
MES_DE_REFERENCIA INT,
ID_FUNCIONARIO INT,
SALARIO_BRUTO MONEY,
INSS DECIMAL(10,2),
SALARIO_LIQUIDO MONEY
)

ALTER TABLE [dbo].[folha_de_pagamento]  WITH CHECK ADD  CONSTRAINT [fk_funcionario_folha] FOREIGN KEY([id_funcionario])
REFERENCES [dbo].[FUNCIONARIO] ([IDFUNCIONARIO])




-------------------------TRIGGERS

1- Vai atualizar a quantidade do estoque na tabela ESTOQUE_DE_MATERIAL, apos inserçao do idproduto na tabela MATERIAL_PRA_CONSUMO. Caso a quantidade em estoque nao seja
suficiente pra atender a demanda, aparecerá um erro.

create or alter trigger trg_atualiza_estoque
on MATERIAL_PRA_CONSUMO
after insert 
as 
begin

declare @qtd int;
declare @id  int;

-- VAI ATUALIZAR A QUANTIDADE DO ESTOQUE QUE FOI USADO NO CONSUMO

begin

select @qtd  =  i.quantidade,
       @id    = ID_ESTOQUE
       from inserted i;

update ESTOQUE_DE_MATERIAL
set QUANTIDADE = QUANTIDADE - @qtd
where idestoque = @id;

PRINT 'RETIRADA CONCLUIDA COM SUCESSO!'

end
if (select quantidade from ESTOQUE_DE_MATERIAL where IDESTOQUE = @id) <= 0

  BEGIN
         raiserror ('QUANTIDADE EM ESTOQUE NAO É SUFICIENTE PARA COMPLETAR SUA SOLICITAÇAO',16,1);
         ROLLBACK TRAN;
    END;


end;





2- Nessa trigger vamos ter alguns blocos com diferentes comandos. Dentro de cada begin vamos ter as explicaçoes:


CREATE OR ALTER TRIGGER TRG_SOMA_PREÇO
 ON PEDIDO
AFTER INSERT 
 AS 
BEGIN

 DECLARE @ID INT;
 DECLARE @TOTAL MONEY;
 DECLARE @IDP INT;
 DECLARE @ANDAMENTO MONEY;
 DECLARE @META MONEY;
 DECLARE @DATA DATE;
 DECLARE @IDVENDEDOR INT;

  SELECT @ID = I.ID_VENDEDOR 
         FROM inserted I; 
SELECT @IDP = IDPEDIDO 
FROM inserted I;


-- AQUI VAI PEGAR A QUANTIDADE * O VALOR DO PRODUTO E SOMA E FAZER UM UPDATE NA COLUNA PREÇO TOTAL DO COM A ULTIMA DATA DO PEDIDO

 SELECT @TOTAL = (SELECT (PRO.PREÇO * PE.QUANTIDADE)
FROM PRODUTO PRO
INNER JOIN PEDIDO PE
ON PRO.IDPRODUTO = PE.ID_PRODUTO
WHERE PE.ID_VENDEDOR = @ID AND IDPEDIDO = @IDP AND DATA_DE_EMISSAO = (SELECT MAX(DATA_DE_EMISSAO) FROM PEDIDO))

  UPDATE PEDIDO
 SET PREÇO_TOTAL = @TOTAL
 WHERE ID_VENDEDOR = @ID AND IDPEDIDO = @IDP AND DATA_DE_EMISSAO = (SELECT MAX(DATA_DE_EMISSAO) FROM PEDIDO) ;

 PRINT 'VALOR TOTAL DO PEDIDO ATUALIZADO COM SUCESSO!'

-- Abaixo vamos fazer um UPDATE apos o vendedor finalizar um pedido, e vai pegar o valor total do pedido dele e acrescentar ao ANDAMENTO (que é o valor ja vendido por esse vendedor
até o momento)

  UPDATE META_VENDEDOR
     SET ANDAMENTO = COALESCE(ANDAMENTO, 0) + @TOTAL
    FROM META_VENDEDOR 
    WHERE ID_VENDEDOR = @ID;

 PRINT 'VALOR DA META DO VENDEDOR '+ CAST(@ID AS VARCHAR) + ' FOI ATUALIZADA COM SUCESSO!' ;

SELECT @META = (SELECT VALOR_META FROM META_VENDEDOR WHERE ID_VENDEDOR = @ID );
SELECT @ANDAMENTO =  (SELECT ANDAMENTO FROM META_VENDEDOR  WHERE ID_VENDEDOR = @ID)
SELECT @DATA = (SELECT DATA_FINAL_META FROM META_VENDEDOR WHERE ID_VENDEDOR = @ID)
SELECT @IDVENDEDOR = (SELECT  ID_VENDEDOR FROM META_VENDEDOR WHERE ID_VENDEDOR = @ID)


-- Nessa variável vamos comparar se o valor que ele ja vendeu é >= ao valor da META estipulada e a data atual for >= a data prevista pra fechamento da meta se for, vai inserir na tabela HISTORICO_META,
onde ficarão todos os registros das vendas.

IF @ANDAMENTO >= @META  AND GETDATE() >=  @DATA 
BEGIN
    INSERT INTO HISTORICO_META (ID_VENDEDOR, VALOR_META, ANDAMENTO, DATA_FINAL_META)
    VALUES (@IDVENDEDOR, @META, @ANDAMENTO, @DATA)


    -- Aqui, vamos selecionar a linha específica para atualização
    UPDATE META_VENDEDOR
    SET ANDAMENTO = 0 ,
	DATA_FINAL_META =  GETDATE()+30
    WHERE ID_VENDEDOR = @ID AND ANDAMENTO >= @META;

    PRINT 'A META DO VENDEDOR  ' + CAST(@ID AS VARCHAR) + ' FOI BATIDA COM SUCESSO DENTRO DO MES ESTIPULADO!'

END
ELSE IF @ANDAMENTO < @META  AND GETDATE() >=  @DATA 
BEGIN
    INSERT INTO HISTORICO_META (ID_VENDEDOR, VALOR_META, ANDAMENTO, DATA_FINAL_META)
    VALUES (@IDVENDEDOR, @META, @ANDAMENTO, @DATA)

    -- Aqui, vamos selecionar a linha específica para atualização. Quando a data final pra meta for igual a data atual, vamos  ZERAR o ANDAMENTO da meta, e acrescentar mais 30 dias 
     pra proxima meta.

    UPDATE META_VENDEDOR
    SET ANDAMENTO = 0,
	DATA_FINAL_META =  GETDATE()+30
    WHERE ID_VENDEDOR = @ID AND ANDAMENTO < @META;

    PRINT '##### ALERTA META NAO BATIDA ##########. O VENDEDOR  ' + CAST(@ID AS VARCHAR) + ' NÃO CONSEGUIU BATER A META!'
END;
END;


3- Explicação no begin abaixo:


CREATE or alter TRIGGER TRG_INSERE_PRODUTO_EM_FABRICAÇAO
ON pedido
AFTER INSERT
AS
BEGIN

declare @nome varchar(100), @cpf varchar(20),@cnpj varchar(25),@id_pedido int,
@idvendedor int,@quantidade int,@data datetime,
@nomep varchar(100),@tipo varchar(200),
@cor varchar(30),@turbo char(5),@portas int, @status varchar(50), @datahj date;


-- aqui vai pegar os resultados do select abaixo e vai inserir na tabela produçao, isso mostra quais produtos estao sendo produzido no momento.

insert into PRODUTO_EM_FABRICAÇAO (data,nome,cpf,cnpj,id_pedido,id_vendedor,quantidade,data_de_entrega,nomep,tipo,cor,turbo,portas,[status])
SELECT getdate(),C.NOME,C.CPF,C.CNPJ,PE.IDPEDIDO,PE.ID_VENDEDOR,PE.QUANTIDADE,PE.DATA_DE_ENTREGA,PRO.NOME,PRO.TIPO,PRO.COR,PRO.TURBO,PRO.PORTAS,'ABERTO'
FROM inserted I 
INNER JOIN PEDIDO PE
ON PE.IDPEDIDO = I.IDPEDIDO
INNER JOIN CLIENTE C  
ON C.IDCLIENTE = PE.ID_CLIENTE
INNER JOIN PRODUTO PRO
ON PRO.IDPRODUTO = PE.ID_PRODUTO 
where pe.IDPEDIDO = i.idpedido

PRINT 'NOVA PRODUÇAO INSERIDA COM SUCESSO!'

END;



4- Toda explicação dentro da trigger.


CREATE OR ALTER TRIGGER TRG_UPDATEFUNCIONARIO
ON HISTORICO_META
AFTER INSERT
AS BEGIN 

DECLARE @ID INT;
DECLARE @ANDAMENTO MONEY;
DECLARE @salario_bruto MONEY;
DECLARE @META MONEY;

SELECT @ID =  ID_VENDEDOR FROM inserted I;

SELECT @salario_bruto = salario_bruto FROM FUNCIONARIO WHERE IDFUNCIONARIO = @id;
SELECT @ANDAMENTO = ANDAMENTO FROM HISTORICO_META WHERE ID_VENDEDOR = @id;
SELECT @META = VALOR_META FROM HISTORICO_META WHERE ID_VENDEDOR = @id;

-- Quando encerrar o mês para os vendedores baterem a meta fechar, vai ser inserido na tabela HISTORICO_META os resultados deles. Apos a inserção, se o valor vendido for >= a META 
estipulada, vamos acrescentar o valor da COMISSÃO para o vendedor. Dai vamos fazer o UPDATE na tabela funcionario no campo salario_bruto.

IF @ANDAMENTO >= @META
BEGIN
  
    UPDATE FUNCIONARIO
    SET SALARIO_BRUTO_COM_COMISSAO = @salario_bruto + @ANDAMENTO * 0.01
    WHERE IDFUNCIONARIO = @ID;

    PRINT '1% DO VALOR DA META BATIDA FOI ACRESCIDO AO SALÁRIO BRUTO DO VENDEDOR ' + CAST(@ID AS VARCHAR);
END;
 END;




---------------------------------PROCEDURES


1- Aqui vamos gerar NOTA FISCAL para o pedido.




CREATE OR ALTER PROCEDURE SP_GERA_NF_CLIENTE (@IDPEDIDO AS INT)
AS
BEGIN
    DECLARE @DATA_DE_EMISSAO DATE, @NOME VARCHAR(60), @CPF VARCHAR(20), @QUANTIDADE INT,
            @CNPJ_FABRICANTE VARCHAR(25), @CNPJ VARCHAR(25), @PREÇO_TOTAL MONEY,
            @PROTOCOLO_DE_AUTENTICAÇAO VARCHAR(100), @IDFABRICAÇAO INT, @ID_PEDIDO INT,
            @NOMEP VARCHAR(100), @TIPO VARCHAR(200), @COR VARCHAR(20), @TURBO CHAR(30),
            @PORTAS INT;

    -- CHECAR PRA VER SE JA NAO TEM UM ID_PEDIDO NA TABELA NF, SE NAO EXISTIR VAI SER EXECUTADO O IF. PRA NAO GERAR DUAS NOTAS FISCAIS PARA O MESMO PEDIDO.

    IF NOT EXISTS (SELECT 1 FROM NF_CLIENTE WHERE ID_PEDIDO = @IDPEDIDO)
    BEGIN
        INSERT INTO NF_CLIENTE (DATA_DE_EMISSAO, NOME, CPF, QUANTIDADE, CNPJ_FABRICANTE, CNPJ, PREÇO_TOTAL, PROTOCOLO_DE_AUTENTICAÇAO, ID_FABRICACAO, ID_PEDIDO, NOMEP, TIPO, COR, TURBO, PORTAS)
        SELECT GETDATE(), F.NOME, F.CPF, F.QUANTIDADE, '163.500.400/0010-00', F.CNPJ, P.PREÇO_TOTAL, NEWID(), F.IDFABRICAÇAO, P.IDPEDIDO, F.NOMEP, F.TIPO, F.COR, F.TURBO, F.PORTAS
        FROM PRODUTO_EM_FABRICAÇAO F
        INNER JOIN PEDIDO P 
		ON P.IDPEDIDO = F.ID_PEDIDO
		WHERE IDPEDIDO = @IDPEDIDO;

        PRINT 'NOTA FISCAL GERADA COM SUCESSO!';

    END

    ELSE
    BEGIN
        PRINT 'NOTA FISCAL JÁ EXISTENTE PARA O PEDIDO!';
    END

-- VAI VERIFICAR SE EXISTE UM ID_PEDIDO  NA TABELA FABRICAÇAO, E NAO ESTA FECHADO. CASO ESSE ID_PEDIDO QUE VAMOS INSERIR ESTEJA ABERTO VAMOS EXECUTAR O IF QUE IRA FECHAR ESSE PEDIDO.

IF NOT EXISTS (SELECT [STATUS] FROM PRODUTO_EM_FABRICAÇAO WHERE ID_PEDIDO = @IDPEDIDO AND [STATUS] = 'FECHADO')
BEGIN
  
    UPDATE PRODUTO_EM_FABRICAÇAO
    SET [STATUS] = 'FECHADO'
    WHERE ID_PEDIDO = @IDPEDIDO;

	  PRINT 'PRODUÇÃO FECHADA COM SUCESSO!';
END

   ELSE
   BEGIN
       PRINT 'NÃO TEM PEDIDO A SER FECHADO!'
   END
END;



2- Vamos usar essa procedure para fazer consultas de todos os materiais usados para o PEDIDO desejado.

OBS: Usamos o OPTION (RECOMPILE) porque estava dando Parâmetro Sniffing.


CREATE OR ALTER PROCEDURE SP_CONSULTA_MATERIAL (@IDPEDIDO AS INT)
AS
BEGIN

SELECT E.ID_FORNECEDOR,E.LOTE,E.NOME,E.TIPO,E.COR,E.TAMANHO,E.DATA_DE_VALIDADE,M.DATA_DE_SAIDA,M.ID_PEDIDO,M.ID_ESTOQUE,M.QUANTIDADE
FROM ESTOQUE_DE_MATERIAL E
INNER JOIN MATERIAL_PRA_CONSUMO M
ON E.IDESTOQUE = M.ID_ESTOQUE
WHERE ID_PEDIDO = @IDPEDIDO
OPTION (RECOMPILE)

PRINT 'MATERIAIS QUE FORAM SELECIONADOS PARA O PEDIDO ' + CAST(@IDPEDIDO AS VARCHAR)
END;



3- Vamos consultar as VENDAS pelo id do VENDEDOR e pelo mes e ano.

OBS: Usamos o OPTION (RECOMPILE) porque estava dando Parâmetro Sniffing.


CREATE OR ALTER PROCEDURE SP_CONSULTA_VENDAS_VENDEDOR (@IDVENDEDOR AS INT,@MES AS INT,@ANO AS INT)
AS
BEGIN
SELECT F.NOME AS VENDEDOR,F.ESTADO,PRO.NOME,PRO.TIPO,PRO.COR,PRO.TURBO,PRO.PORTAS,PRO.PREÇO,A.ID_FUNCIONARIO,M.VALOR_META,M.ANDAMENTO,PE.DATA_DE_EMISSAO AS DATA_DE_EMISSAO_PEDIDO
FROM FUNCIONARIO F
INNER JOIN AREA_DE_ATUAÇAO_VENDEDOR A
ON F.IDFUNCIONARIO = A.ID_FUNCIONARIO
INNER JOIN META_VENDEDOR M
ON A.IDVENDEDOR = M.ID_VENDEDOR
INNER JOIN PEDIDO PE
ON A.IDVENDEDOR = PE.ID_VENDEDOR
INNER JOIN PRODUTO PRO
ON PRO.IDPRODUTO = PE. ID_PRODUTO
WHERE IDVENDEDOR = @IDVENDEDOR AND MONTH(DATA_DE_EMISSAO) = @MES AND YEAR(DATA_DE_EMISSAO) = @ANO
OPTION (RECOMPILE)

END;




4- Vamos consultar o status do pedido do CLIENTE pelo CPF e mes e ano.

OBS: Usamos o OPTION (RECOMPILE) porque estava dando Parâmetro Sniffing.

CREATE OR ALTER PROCEDURE SP_CONSULTA_STATUS_PEDIDO (@CPF AS VARCHAR(20),@MES AS INT,@ANO AS INT)
AS 
BEGIN
SELECT C.NOME,C.CPF,C.CNPJ,PRO.NOME,PE.DATA_DE_EMISSAO,PE.DATA_DE_ENTREGA,PE.PREÇO_TOTAL,F.ID_VENDEDOR,F.[STATUS]
FROM CLIENTE C
INNER JOIN PEDIDO PE
ON C.IDCLIENTE = PE.ID_CLIENTE
INNER JOIN PRODUTO PRO
ON PRO.IDPRODUTO = PE.ID_PRODUTO
INNER JOIN PRODUTO_EM_FABRICAÇAO F
ON PE.IDPEDIDO = F.ID_PEDIDO
WHERE C.CPF = @CPF AND MONTH(DATA_DE_EMISSAO) = @MES AND YEAR(DATA_DE_EMISSAO) = @ANO
option (recompile)

END;


5- Vamos consultar NOTA FISCAL pelo numero do pedido, ou do id da fabricação.

CREATE PROCEDURE SP_CONSULTA_NF (@IDPEDIDO AS INT,@IDFABRICAÇAO AS INT)
AS
BEGIN

SELECT * FROM NF_CLIENTE WHERE ID_PEDIDO = @IDPEDIDO OR ID_FABRICAÇAO = @IDFABRICAÇAO

END;



6- Vamos consultar as vendas por ESTADO mes e ano, ou só pelo mes e ano. 

@estado = 'go', @mes = 12, @ano = 2023

@estado = null, @mes = 12, @ano = 2023  = Vai trazer todos os estados pelo mes e ano.

OBS: coloquei ORDER BY, porém pra performance não é recomendado.


CREATE OR ALTER PROCEDURE SP_VENDAS_POR_ESTADO (@ESTADO AS CHAR(3),@MES AS INT, @ANO AS INT)
AS
BEGIN

IF @ESTADO IS NOT NULL AND @MES <> 0 AND @ANO <> 0
BEGIN

SELECT E.UF,PE.DATA_DE_EMISSAO,SUM(PE.PREÇO_TOTAL) AS TOTAL_DE_CADA_VENDA
FROM ESTADO E
INNER JOIN AREA_DE_ATUAÇAO_VENDEDOR A
ON E.IDESTADO = A.ID_ESTADO
INNER JOIN PEDIDO PE
ON A.IDVENDEDOR = PE.ID_VENDEDOR
WHERE E.UF = @ESTADO AND MONTH(DATA_DE_EMISSAO) = @MES AND YEAR(DATA_DE_EMISSAO) = @ANO
GROUP BY E.UF, PE.DATA_DE_EMISSAO
ORDER BY  TOTAL_DE_CADA_VENDA DESC
END

IF @ESTADO IS NULL AND @MES <> 0 AND @ANO <> 0
  BEGIN
  
  SELECT E.UF,PE.DATA_DE_EMISSAO,SUM(PE.PREÇO_TOTAL) AS TOTAL_DE_CADA_VENDA
FROM ESTADO E
INNER JOIN AREA_DE_ATUAÇAO_VENDEDOR A
ON E.IDESTADO = A.ID_ESTADO
INNER JOIN PEDIDO PE
ON A.IDVENDEDOR = PE.ID_VENDEDOR
WHERE  MONTH(DATA_DE_EMISSAO) = @MES AND YEAR(DATA_DE_EMISSAO) = @ANO
GROUP BY E.UF, PE.DATA_DE_EMISSAO
ORDER BY  TOTAL_DE_CADA_VENDA DESC

END
   
END;


7- Aqui vamos fazer o pagamento do funcionario. Vamos passar o ID DO FUNCIONARIO E O VALOR DO DESCONTO DO INSS. Apos isso, vai ser inserido na tabela folha de pagamento ja com o
desconto e com o valor do salario liquido do funcionario.


CREATE OR ALTER PROCEDURE SP_PAGAMENTO_FUNCIONARIO
    @ID AS INT,
    @CALCULO DECIMAL(10,2)
AS
BEGIN
    DECLARE @BRUTO DECIMAL(10,2);
    DECLARE @SOMA DECIMAL(10,2);
    DECLARE @data DATE;
    DECLARE @COMISSAO MONEY;
    DECLARE @SOMA2 DECIMAL(10,2);

    SELECT @data = (SELECT data_final_meta FROM HISTORICO_META WHERE ID_VENDEDOR = @ID);

    -- OBS: ESTAVA PEGANDO O VALOR ANTIGO MESMO DEPOIS DO UPDATE, ENTAO EU COLOQUEI ESSE SELECT APOS O UPDATE, PQ ELE ESTAA ANTES, ASSIM ESTAVA PEGANDO O VALOR ANTIGO. PQ ESSE SELECT ESTAVA ANTES DO UPDATE
    -- ASSIM ELE PEGAVA OS VALORES ANTIGOS. AGORA EU COLOQUE ELE APOS O UPDATE ONDE ELE ESTA AGORA. ASSIM PEGA O VALOR APOS O UPDATE.

    SELECT @COMISSAO = (SELECT SALARIO_BRUTO_COM_COMISSAO FROM FUNCIONARIO WHERE IDFUNCIONARIO = @ID);

    SELECT @SOMA2 = (SELECT SALARIO_BRUTO_COM_COMISSAO * @CALCULO/100 FROM FUNCIONARIO WHERE IDFUNCIONARIO = @ID);
    SELECT @SOMA = (SELECT SALARIO_BRUTO * @CALCULO/100 FROM FUNCIONARIO WHERE IDFUNCIONARIO = @ID);


    IF @COMISSAO IS NOT NULL AND @data = getdate() 
    BEGIN
        INSERT INTO FOLHA_DE_PAGAMENTO (DATA_DO_PAGAMENTO, MES_DE_REFERENCIA, ID_FUNCIONARIO, SALARIO_BRUTO, INSS, SALARIO_LIQUIDO)
        VALUES (GETDATE(), MONTH(GETDATE()), @ID, @COMISSAO, @CALCULO, @SOMA);

        PRINT 'INSERÇÃO NA FOLHA DE PAGAMENTO DOS FUNCIONÁRIOS!  FOLHA DE PAGAMENTO DO FUNCIONÁRIO COM O ID  ' + CAST(@ID AS VARCHAR) + ' FOI GERADA COM SUCESSO!';

        UPDATE FOLHA_DE_PAGAMENTO
        SET SALARIO_LIQUIDO = @COMISSAO - @SOMA2
        WHERE ID_FUNCIONARIO = @ID;

        PRINT 'INSS DO FUNCIONÁRIO  ' + CAST(@ID AS VARCHAR) + ' FOI DESCONTADO COM SUCESSO.';
    END;

    SELECT @BRUTO = (SELECT SALARIO_BRUTO FROM FUNCIONARIO WHERE IDFUNCIONARIO = @ID);

-- AQUI PRA BAIXO NAO ESTA FUNCIONANDO

IF @COMISSAO = 0.00 AND @data = getdate() 
BEGIN
    -- Verifica se já existe um registro com o ID_FUNCIONARIO especificado
    IF NOT EXISTS (SELECT 1 FROM FOLHA_DE_PAGAMENTO WHERE ID_FUNCIONARIO = @ID)
    BEGIN
        -- Se nenhum registro existe, então realiza a INSERT
        INSERT INTO FOLHA_DE_PAGAMENTO (DATA_DO_PAGAMENTO, MES_DE_REFERENCIA, ID_FUNCIONARIO, SALARIO_BRUTO, INSS, SALARIO_LIQUIDO)
        VALUES (GETDATE(), MONTH(GETDATE()), @ID, @BRUTO, @CALCULO, @SOMA);

        PRINT 'INSERÇÃO NA FOLHA DE PAGAMENTO DOS FUNCIONÁRIOS!  FOLHA DE PAGAMENTO DO FUNCIONÁRIO COM O ID  ' + CAST(@ID AS VARCHAR) + ' FOI GERADA COM SUCESSO!';
    END
    ELSE
    BEGIN
        -- Se um registro já existe, então realiza a UPDATE
        UPDATE FOLHA_DE_PAGAMENTO
        SET SALARIO_BRUTO = @BRUTO,  -- Adicione esta linha para garantir que SALARIO_BRUTO seja atualizado
            SALARIO_LIQUIDO = @BRUTO - @SOMA
        WHERE ID_FUNCIONARIO = @ID;

        PRINT 'INSS DO FUNCIONÁRIO  ' + CAST(@ID AS VARCHAR) + ' FOI DESCONTADO COM SUCESSO.';
    END;
END;

    ELSE 
    BEGIN
        PRINT 'FORA DA DATA DE FECHAMENTO DE SALARIO! A OPERAÇÃO FOI CANCELADA!';
    END;

IF @COMISSAO <> 0.00
	BEGIN

	UPDATE FUNCIONARIO
	SET SALARIO_BRUTO_COM_COMISSAO = 0
	WHERE IDFUNCIONARIO = @ID

	END;
END;

8- aqui vamos consulta o contra cheque do funcionario, com base no CPF dele

create or alter  procedure sp_consulta_pagamento (@cpf varchar(15))
as
begin

select f.data_de_admissao, f.nome, f.cpf,f.pis, c.nome AS CARGO,p.data_do_pagamento,p.mes_de_referencia,p.salario_bruto,p.inss,p.salario_liquido,'FABRICAR'AS EMPRESA,'163.500.400/0010-00'as CNPJ_EMPRESA
from CARGO c
inner join FUNCIONARIO f
on c.IDCARGO = f.ID_CARGO
inner join folha_de_pagamento p
on f.IDFUNCIONARIO = p.id_funcionario
where f.CPF = @cpf
order by p.data_do_pagamento desc

end;


