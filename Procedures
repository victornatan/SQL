---------------------------------PROCEDURES


1- Aqui vamos gerar NOTA FISCAL para o pedido.




CREATE OR ALTER PROCEDURE SP_GERA_NF_CLIENTE (@IDPEDIDO AS INT)
AS
BEGIN
    DECLARE @DATA_DE_EMISSAO DATE, @NOME VARCHAR(60), @CPF VARCHAR(20), @QUANTIDADE INT,
            @CNPJ_FABRICANTE VARCHAR(25), @CNPJ VARCHAR(25), @PREÇO_TOTAL MONEY,
            @PROTOCOLO_DE_AUTENTICAÇAO VARCHAR(100), @IDFABRICAÇAO INT, @ID_PEDIDO INT,
            @NOMEP VARCHAR(100), @TIPO VARCHAR(200), @COR VARCHAR(20), @TURBO CHAR(30),
            @PORTAS INT;

    -- CHECAR PRA VER SE JA NAO TEM UM ID_PEDIDO NA TABELA NF, SE NAO EXISTIR VAI SER EXECUTADO O IF. PRA NAO GERAR DUAS NOTAS FISCAIS PARA O MESMO PEDIDO.

    IF NOT EXISTS (SELECT 1 FROM NF_CLIENTE WHERE ID_PEDIDO = @IDPEDIDO)
    BEGIN
        INSERT INTO NF_CLIENTE (DATA_DE_EMISSAO, NOME, CPF, QUANTIDADE, CNPJ_FABRICANTE, CNPJ, PREÇO_TOTAL, PROTOCOLO_DE_AUTENTICAÇAO, ID_FABRICACAO, ID_PEDIDO, NOMEP, TIPO, COR, TURBO, PORTAS)
        SELECT GETDATE(), F.NOME, F.CPF, F.QUANTIDADE, '163.500.400/0010-00', F.CNPJ, P.PREÇO_TOTAL, NEWID(), F.IDFABRICAÇAO, P.IDPEDIDO, F.NOMEP, F.TIPO, F.COR, F.TURBO, F.PORTAS
        FROM PRODUTO_EM_FABRICAÇAO F
        INNER JOIN PEDIDO P 
		ON P.IDPEDIDO = F.ID_PEDIDO
		WHERE IDPEDIDO = @IDPEDIDO;

        PRINT 'NOTA FISCAL GERADA COM SUCESSO!';

    END

    ELSE
    BEGIN
        PRINT 'NOTA FISCAL JÁ EXISTENTE PARA O PEDIDO!';
    END

-- VAI VERIFICAR SE EXISTE UM ID_PEDIDO  NA TABELA FABRICAÇAO, E NAO ESTA FECHADO. CASO ESSE ID_PEDIDO QUE VAMOS INSERIR ESTEJA ABERTO VAMOS EXECUTAR O IF QUE IRA FECHAR ESSE PEDIDO.

IF NOT EXISTS (SELECT [STATUS] FROM PRODUTO_EM_FABRICAÇAO WHERE ID_PEDIDO = @IDPEDIDO AND [STATUS] = 'FECHADO')
BEGIN
  
    UPDATE PRODUTO_EM_FABRICAÇAO
    SET [STATUS] = 'FECHADO'
    WHERE ID_PEDIDO = @IDPEDIDO;

	  PRINT 'PRODUÇÃO FECHADA COM SUCESSO!';
END

   ELSE
   BEGIN
       PRINT 'NÃO TEM PEDIDO A SER FECHADO!'
   END
END;



2- Vamos usar essa procedure para fazer consultas de todos os materiais usados para o PEDIDO desejado.

OBS: Usamos o OPTION (RECOMPILE) porque estava dando Parâmetro Sniffing.


CREATE OR ALTER PROCEDURE SP_CONSULTA_MATERIAL (@IDPEDIDO AS INT)
AS
BEGIN

SELECT E.ID_FORNECEDOR,E.LOTE,E.NOME,E.TIPO,E.COR,E.TAMANHO,E.DATA_DE_VALIDADE,M.DATA_DE_SAIDA,M.ID_PEDIDO,M.ID_ESTOQUE,M.QUANTIDADE
FROM ESTOQUE_DE_MATERIAL E
INNER JOIN MATERIAL_PRA_CONSUMO M
ON E.IDESTOQUE = M.ID_ESTOQUE
WHERE ID_PEDIDO = @IDPEDIDO
OPTION (RECOMPILE)

PRINT 'MATERIAIS QUE FORAM SELECIONADOS PARA O PEDIDO ' + CAST(@IDPEDIDO AS VARCHAR)
END;



3- Vamos consultar as VENDAS pelo id do VENDEDOR e pelo mes e ano.

OBS: Usamos o OPTION (RECOMPILE) porque estava dando Parâmetro Sniffing.


CREATE OR ALTER PROCEDURE SP_CONSULTA_VENDAS_VENDEDOR (@IDVENDEDOR AS INT,@MES AS INT,@ANO AS INT)
AS
BEGIN
SELECT F.NOME AS VENDEDOR,F.ESTADO,PRO.NOME,PRO.TIPO,PRO.COR,PRO.TURBO,PRO.PORTAS,PRO.PREÇO,A.ID_FUNCIONARIO,M.VALOR_META,M.ANDAMENTO,PE.DATA_DE_EMISSAO AS DATA_DE_EMISSAO_PEDIDO
FROM FUNCIONARIO F
INNER JOIN AREA_DE_ATUAÇAO_VENDEDOR A
ON F.IDFUNCIONARIO = A.ID_FUNCIONARIO
INNER JOIN META_VENDEDOR M
ON A.IDVENDEDOR = M.ID_VENDEDOR
INNER JOIN PEDIDO PE
ON A.IDVENDEDOR = PE.ID_VENDEDOR
INNER JOIN PRODUTO PRO
ON PRO.IDPRODUTO = PE. ID_PRODUTO
WHERE IDVENDEDOR = @IDVENDEDOR AND MONTH(DATA_DE_EMISSAO) = @MES AND YEAR(DATA_DE_EMISSAO) = @ANO
OPTION (RECOMPILE)

END;




4- Vamos consultar o status do pedido do CLIENTE pelo CPF e mes e ano.

OBS: Usamos o OPTION (RECOMPILE) porque estava dando Parâmetro Sniffing.

CREATE OR ALTER PROCEDURE SP_CONSULTA_STATUS_PEDIDO (@CPF AS VARCHAR(20),@MES AS INT,@ANO AS INT)
AS 
BEGIN
SELECT C.NOME,C.CPF,C.CNPJ,PRO.NOME,PE.DATA_DE_EMISSAO,PE.DATA_DE_ENTREGA,PE.PREÇO_TOTAL,F.ID_VENDEDOR,F.[STATUS]
FROM CLIENTE C
INNER JOIN PEDIDO PE
ON C.IDCLIENTE = PE.ID_CLIENTE
INNER JOIN PRODUTO PRO
ON PRO.IDPRODUTO = PE.ID_PRODUTO
INNER JOIN PRODUTO_EM_FABRICAÇAO F
ON PE.IDPEDIDO = F.ID_PEDIDO
WHERE C.CPF = @CPF AND MONTH(DATA_DE_EMISSAO) = @MES AND YEAR(DATA_DE_EMISSAO) = @ANO
option (recompile)

END;


5- Vamos consultar NOTA FISCAL pelo numero do pedido, ou do id da fabricação.

CREATE PROCEDURE SP_CONSULTA_NF (@IDPEDIDO AS INT,@IDFABRICAÇAO AS INT)
AS
BEGIN

SELECT * FROM NF_CLIENTE WHERE ID_PEDIDO = @IDPEDIDO OR ID_FABRICAÇAO = @IDFABRICAÇAO

END;



6- Vamos consultar as vendas por ESTADO mes e ano, ou só pelo mes e ano. 

@estado = 'go', @mes = 12, @ano = 2023

@estado = null, @mes = 12, @ano = 2023  = Vai trazer todos os estados pelo mes e ano.

OBS: coloquei ORDER BY, porém pra performance não é recomendado.


CREATE OR ALTER PROCEDURE SP_VENDAS_POR_ESTADO (@ESTADO AS CHAR(3),@MES AS INT, @ANO AS INT)
AS
BEGIN

IF @ESTADO IS NOT NULL AND @MES <> 0 AND @ANO <> 0
BEGIN

SELECT E.UF,PE.DATA_DE_EMISSAO,SUM(PE.PREÇO_TOTAL) AS TOTAL_DE_CADA_VENDA
FROM ESTADO E
INNER JOIN AREA_DE_ATUAÇAO_VENDEDOR A
ON E.IDESTADO = A.ID_ESTADO
INNER JOIN PEDIDO PE
ON A.IDVENDEDOR = PE.ID_VENDEDOR
WHERE E.UF = @ESTADO AND MONTH(DATA_DE_EMISSAO) = @MES AND YEAR(DATA_DE_EMISSAO) = @ANO
GROUP BY E.UF, PE.DATA_DE_EMISSAO
ORDER BY  TOTAL_DE_CADA_VENDA DESC
END

IF @ESTADO IS NULL AND @MES <> 0 AND @ANO <> 0
  BEGIN
  
  SELECT E.UF,PE.DATA_DE_EMISSAO,SUM(PE.PREÇO_TOTAL) AS TOTAL_DE_CADA_VENDA
FROM ESTADO E
INNER JOIN AREA_DE_ATUAÇAO_VENDEDOR A
ON E.IDESTADO = A.ID_ESTADO
INNER JOIN PEDIDO PE
ON A.IDVENDEDOR = PE.ID_VENDEDOR
WHERE  MONTH(DATA_DE_EMISSAO) = @MES AND YEAR(DATA_DE_EMISSAO) = @ANO
GROUP BY E.UF, PE.DATA_DE_EMISSAO
ORDER BY  TOTAL_DE_CADA_VENDA DESC

END
   
END;


7- Aqui vamos fazer o pagamento do funcionario. Vamos passar o ID DO FUNCIONARIO E O VALOR DO DESCONTO DO INSS. Apos isso, vai ser inserido na tabela folha de pagamento ja com o
desconto e com o valor do salario liquido do funcionario.


CREATE OR ALTER PROCEDURE SP_PAGAMENTO_FUNCIONARIO
    @ID AS INT,
    @CALCULO DECIMAL(10,2)
AS
BEGIN
    DECLARE @BRUTO DECIMAL(10,2);
    DECLARE @SOMA DECIMAL(10,2);
    DECLARE @data DATE;
    DECLARE @COMISSAO MONEY;
    DECLARE @SOMA2 DECIMAL(10,2);

    SELECT @data = (SELECT data_final_meta FROM HISTORICO_META WHERE ID_VENDEDOR = @ID);

    -- OBS: ESTAVA PEGANDO O VALOR ANTIGO MESMO DEPOIS DO UPDATE, ENTAO EU COLOQUEI ESSE SELECT APOS O UPDATE, PQ ELE ESTAA ANTES, ASSIM ESTAVA PEGANDO O VALOR ANTIGO. PQ ESSE SELECT ESTAVA ANTES DO UPDATE
    -- ASSIM ELE PEGAVA OS VALORES ANTIGOS. AGORA EU COLOQUE ELE APOS O UPDATE ONDE ELE ESTA AGORA. ASSIM PEGA O VALOR APOS O UPDATE.

    SELECT @COMISSAO = (SELECT SALARIO_BRUTO_COM_COMISSAO FROM FUNCIONARIO WHERE IDFUNCIONARIO = @ID);

    SELECT @SOMA2 = (SELECT SALARIO_BRUTO_COM_COMISSAO * @CALCULO/100 FROM FUNCIONARIO WHERE IDFUNCIONARIO = @ID);
    SELECT @SOMA = (SELECT SALARIO_BRUTO * @CALCULO/100 FROM FUNCIONARIO WHERE IDFUNCIONARIO = @ID);


    IF @COMISSAO IS NOT NULL AND @data = getdate() 
    BEGIN
        INSERT INTO FOLHA_DE_PAGAMENTO (DATA_DO_PAGAMENTO, MES_DE_REFERENCIA, ID_FUNCIONARIO, SALARIO_BRUTO, INSS, SALARIO_LIQUIDO)
        VALUES (GETDATE(), MONTH(GETDATE()), @ID, @COMISSAO, @CALCULO, @SOMA);

        PRINT 'INSERÇÃO NA FOLHA DE PAGAMENTO DOS FUNCIONÁRIOS!  FOLHA DE PAGAMENTO DO FUNCIONÁRIO COM O ID  ' + CAST(@ID AS VARCHAR) + ' FOI GERADA COM SUCESSO!';

        UPDATE FOLHA_DE_PAGAMENTO
        SET SALARIO_LIQUIDO = @COMISSAO - @SOMA2
        WHERE ID_FUNCIONARIO = @ID;

        PRINT 'INSS DO FUNCIONÁRIO  ' + CAST(@ID AS VARCHAR) + ' FOI DESCONTADO COM SUCESSO.';
    END;

    SELECT @BRUTO = (SELECT SALARIO_BRUTO FROM FUNCIONARIO WHERE IDFUNCIONARIO = @ID);

-- AQUI PRA BAIXO NAO ESTA FUNCIONANDO

IF @COMISSAO = 0.00 AND @data = getdate() 
BEGIN
    -- Verifica se já existe um registro com o ID_FUNCIONARIO especificado
    IF NOT EXISTS (SELECT 1 FROM FOLHA_DE_PAGAMENTO WHERE ID_FUNCIONARIO = @ID)
    BEGIN
        -- Se nenhum registro existe, então realiza a INSERT
        INSERT INTO FOLHA_DE_PAGAMENTO (DATA_DO_PAGAMENTO, MES_DE_REFERENCIA, ID_FUNCIONARIO, SALARIO_BRUTO, INSS, SALARIO_LIQUIDO)
        VALUES (GETDATE(), MONTH(GETDATE()), @ID, @BRUTO, @CALCULO, @SOMA);

        PRINT 'INSERÇÃO NA FOLHA DE PAGAMENTO DOS FUNCIONÁRIOS!  FOLHA DE PAGAMENTO DO FUNCIONÁRIO COM O ID  ' + CAST(@ID AS VARCHAR) + ' FOI GERADA COM SUCESSO!';
    END
    ELSE
    BEGIN
        -- Se um registro já existe, então realiza a UPDATE
        UPDATE FOLHA_DE_PAGAMENTO
        SET SALARIO_BRUTO = @BRUTO,  -- Adicione esta linha para garantir que SALARIO_BRUTO seja atualizado
            SALARIO_LIQUIDO = @BRUTO - @SOMA
        WHERE ID_FUNCIONARIO = @ID;

        PRINT 'INSS DO FUNCIONÁRIO  ' + CAST(@ID AS VARCHAR) + ' FOI DESCONTADO COM SUCESSO.';
    END;
END;

    ELSE 
    BEGIN
        PRINT 'FORA DA DATA DE FECHAMENTO DE SALARIO! A OPERAÇÃO FOI CANCELADA!';
    END;

IF @COMISSAO <> 0.00
	BEGIN

	UPDATE FUNCIONARIO
	SET SALARIO_BRUTO_COM_COMISSAO = 0
	WHERE IDFUNCIONARIO = @ID

	END;
END;

8- aqui vamos consulta o contra cheque do funcionario, com base no CPF dele

create or alter  procedure sp_consulta_pagamento (@cpf varchar(15))
as
begin

select f.data_de_admissao, f.nome, f.cpf,f.pis, c.nome AS CARGO,p.data_do_pagamento,p.mes_de_referencia,p.salario_bruto,p.inss,p.salario_liquido,'FABRICAR'AS EMPRESA,'163.500.400/0010-00'as CNPJ_EMPRESA
from CARGO c
inner join FUNCIONARIO f
on c.IDCARGO = f.ID_CARGO
inner join folha_de_pagamento p
on f.IDFUNCIONARIO = p.id_funcionario
where f.CPF = @cpf
order by p.data_do_pagamento desc

end;



CREATE OR ALTER PROCEDURE SP_INFO_VENDEDOR (@IDVENDEDOR AS INT)
AS
BEGIN
	SELECT FUNC.NOME,FUNC.CPF, FUNC.CIDADE, FUNC.ESTADO, FUNC.DDD, FUNC.TELEFONE ,AREA.IDVENDEDOR
	FROM FUNCIONARIO FUNC
	INNER JOIN AREA_DE_ATUAÇAO_VENDEDOR AREA
	ON FUNC.IDFUNCIONARIO = AREA.ID_FUNCIONARIO
	WHERE IDVENDEDOR = @IDVENDEDOR

END;
